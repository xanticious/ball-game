<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bouncing Balls Economy Game</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(45deg, #2c5aa0, #3d72c7);
        overflow: hidden;
        height: 100vh;
      }

      #gameCanvas {
        display: block;
        background: linear-gradient(135deg, #7b68ee 0%, #9370db 100%);
        border: 2px solid #444;
      }

      .ui {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        z-index: 10;
      }

      .money {
        font-size: 24px;
        margin-bottom: 20px;
        background: rgba(0, 0, 0, 0.4);
        padding: 10px 15px;
        border-radius: 10px;
        border: 2px solid #ffd700;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
      }

      .buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      button {
        background: linear-gradient(45deg, #ff4757, #ff3838);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      button:active {
        transform: translateY(0);
      }

      button:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
      }

      .upgrade-btn {
        background: linear-gradient(45deg, #00d2ff, #3a7bd5);
      }

      .reset-btn {
        background: linear-gradient(45deg, #ff6b35, #f7931e);
      }

      .stats {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        background: rgba(0, 0, 0, 0.4);
        padding: 10px 15px;
        border-radius: 10px;
        font-size: 14px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .hud-toggle {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 5px 8px;
        border-radius: 4px;
        font-size: 10px;
        font-weight: normal;
        cursor: pointer;
        transition: all 0.2s ease;
        z-index: 15;
      }

      .hud-toggle:hover {
        background: rgba(0, 0, 0, 0.7);
        transform: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .color-controls {
        position: absolute;
        bottom: 20px;
        right: 70px;
        display: flex;
        gap: 5px;
        z-index: 15;
      }

      .color-btn {
        width: 20px;
        height: 20px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
        transform: none !important;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      }

      .color-btn:hover {
        border-color: rgba(255, 255, 255, 0.6);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        transform: none !important;
      }

      .color-btn.active {
        border-color: white;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }

      .hud-hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui">
      <div class="money" id="moneyDisplay">$0</div>
      <div class="buttons">
        <button id="addBallBtn">+ Ball ($100)</button>
        <button id="upgradeSpeedBtn" class="upgrade-btn">
          Upgrade Speed ($10.0k)
        </button>
        <button id="resetBtn" class="reset-btn">Reset Game</button>
      </div>
    </div>

    <div class="stats">
      <div>Balls: <span id="ballCount">0</span></div>
      <div>Speed Multiplier: <span id="speedMultiplier">1.00x</span></div>
      <div>Ball Cost: <span id="ballCost">$100</span></div>
      <div>Speed Cost: <span id="speedCost">$10.0k</span></div>
      <div>Total Earned: <span id="totalEarned">$0</span></div>
      <div>Income: <span id="estimatedIncome">~ $0 / min</span></div>
      <div>Buy Next ETA: <span id="buyNextETA">Now</span></div>
    </div>

    <button id="hudToggle" class="hud-toggle">HUD</button>

    <div id="colorControls" class="color-controls">
      <!-- Color buttons will be generated dynamically -->
    </div>

    <script>
      // Game variables
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Set canvas size
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Game state
      let money = 0;
      let balls = [];
      let obstacles = [];
      let ballCost = 100;
      let speedUpgradeCost = 10000;
      let speedMultiplier = 1.0;
      let ballCount = 0;
      let autoSaveTimer = 0;
      let hudVisible = true;

      // Income tracking
      let totalEarned = 0;
      let lastTotalEarned = 0;
      let estimatedIncome = 0;
      let incomeTimer = 0;

      // Background color cycling
      let backgroundTimer = 0;
      let currentColorIndex = 0;
      let nextColorIndex = 1;
      let colorTransitionProgress = 0;

      // Color themes for background cycling (30 minutes total, ~2.5 min per color)
      const colorThemes = [
        { name: "purple", colors: ["#6a4c93", "#9d5ec9"] },
        { name: "pink", colors: ["#e91e63", "#f48fb1"] },
        { name: "red", colors: ["#d32f2f", "#f44336"] },
        { name: "orange", colors: ["#ff5722", "#ff9800"] },
        { name: "yellow", colors: ["#ffa000", "#ffca28"] },
        { name: "green", colors: ["#388e3c", "#66bb6a"] },
        { name: "blue", colors: ["#1976d2", "#42a5f5"] },
        { name: "teal", colors: ["#00695c", "#26a69a"] },
        { name: "indigo", colors: ["#303f9f", "#5c6bc0"] },
        { name: "brown", colors: ["#5d4037", "#8d6e63"] },
        { name: "gray", colors: ["#424242", "#757575"] },
        { name: "gold", colors: ["#b8860b", "#daa520"] },
      ];

      // Shuffle the color themes array
      function shuffleColorThemes() {
        for (let i = colorThemes.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [colorThemes[i], colorThemes[j]] = [colorThemes[j], colorThemes[i]];
        }
      }

      // Initialize with shuffled themes
      shuffleColorThemes();

      // Function to interpolate between two hex colors
      function interpolateColor(color1, color2, factor) {
        // Remove # if present
        color1 = color1.replace("#", "");
        color2 = color2.replace("#", "");

        // Parse hex colors
        const r1 = parseInt(color1.substr(0, 2), 16);
        const g1 = parseInt(color1.substr(2, 2), 16);
        const b1 = parseInt(color1.substr(4, 2), 16);

        const r2 = parseInt(color2.substr(0, 2), 16);
        const g2 = parseInt(color2.substr(2, 2), 16);
        const b2 = parseInt(color2.substr(4, 2), 16);

        // Interpolate
        const r = Math.round(r1 + (r2 - r1) * factor);
        const g = Math.round(g1 + (g2 - g1) * factor);
        const b = Math.round(b1 + (b2 - b1) * factor);

        // Convert back to hex
        return `#${r.toString(16).padStart(2, "0")}${g
          .toString(16)
          .padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
      }

      // Update background gradient
      function updateBackgroundGradient() {
        const currentTheme = colorThemes[currentColorIndex];
        const nextTheme = colorThemes[nextColorIndex];

        // Interpolate between current and next theme colors
        const color1 = interpolateColor(
          currentTheme.colors[0],
          nextTheme.colors[0],
          colorTransitionProgress
        );
        const color2 = interpolateColor(
          currentTheme.colors[1],
          nextTheme.colors[1],
          colorTransitionProgress
        );

        // Apply the gradient to the canvas
        const canvas = document.getElementById("gameCanvas");
        canvas.style.background = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;

        // Update active color button
        updateActiveColorButton();
      }

      // Create color control buttons
      function createColorButtons() {
        const colorControls = document.getElementById("colorControls");
        colorControls.innerHTML = "";

        colorThemes.forEach((theme, index) => {
          const btn = document.createElement("div");
          btn.className = "color-btn";
          btn.style.background = `linear-gradient(45deg, ${theme.colors[0]}, ${theme.colors[1]})`;
          btn.title = theme.name;
          btn.onclick = () => jumpToColor(index);
          colorControls.appendChild(btn);
        });
      }

      // Jump to specific color in cycle
      function jumpToColor(index) {
        currentColorIndex = index;
        nextColorIndex = (index + 1) % colorThemes.length;
        colorTransitionProgress = 0;
        backgroundTimer = 0; // Reset timer so we stay on this color for full duration
        updateBackgroundGradient();
      }

      // Update active color button highlight
      function updateActiveColorButton() {
        const colorButtons = document.querySelectorAll(".color-btn");
        colorButtons.forEach((btn, index) => {
          if (index === currentColorIndex) {
            btn.classList.add("active");
          } else {
            btn.classList.remove("active");
          }
        });
      }

      // Number formatting for idle game style
      function formatNumber(num) {
        const suffixes = ["", "k", "M", "B", "T", "q", "Q", "s", "S", "O", "N"];
        let suffixIndex = 0;

        while (num >= 1000 && suffixIndex < suffixes.length - 1) {
          num /= 1000;
          suffixIndex++;
        }

        if (suffixIndex === 0) {
          return Math.floor(num).toString();
        } else {
          return num.toFixed(3).replace(/\.?0+$/, "") + suffixes[suffixIndex];
        }
      }

      // Format time duration for ETA display
      function formatDuration(minutes) {
        if (minutes <= 0) return "Now";

        const days = Math.floor(minutes / (24 * 60));
        const hours = Math.floor((minutes % (24 * 60)) / 60);
        const mins = Math.ceil(minutes % 60);

        let result = "~";

        if (days > 0) {
          result += `${days}d`;
          if (hours > 0) result += ` ${hours}h`;
          if (mins > 0 && days === 0) result += ` ${mins}m`;
        } else if (hours > 0) {
          result += `${hours}h`;
          if (mins > 0) result += ` ${mins}m`;
        } else {
          result += `${mins}m`;
        }

        return result;
      }

      // Calculate time until next purchase
      function calculateBuyNextETA() {
        // Find the cheapest purchase option
        const nextPurchaseCost = Math.min(ballCost, speedUpgradeCost);
        const amountLacking = nextPurchaseCost - money;

        if (amountLacking <= 0) {
          return "Now";
        }

        // If no income yet, can't estimate
        if (estimatedIncome <= 0) {
          return "?";
        }

        // Calculate minutes needed
        const estimatedMinutes = amountLacking / estimatedIncome;
        return formatDuration(estimatedMinutes);
      }

      // Save game state to localStorage
      function saveGameState() {
        const gameState = {
          money: money,
          ballCount: ballCount,
          ballCost: ballCost,
          speedUpgradeCost: speedUpgradeCost,
          speedMultiplier: speedMultiplier,
          totalEarned: totalEarned,
          lastTotalEarned: lastTotalEarned,
          estimatedIncome: estimatedIncome,
          ballsData: balls.map((ball) => ({
            x: ball.x,
            y: ball.y,
            radius: ball.radius,
            vx: ball.vx,
            vy: ball.vy,
            color: ball.color,
          })),
          timestamp: Date.now(),
        };
        localStorage.setItem("ballGameSave", JSON.stringify(gameState));
        console.log("Game saved!");
      }

      // Load game state from localStorage
      function loadGameState() {
        const savedState = localStorage.getItem("ballGameSave");
        if (savedState) {
          try {
            const gameState = JSON.parse(savedState);
            money = gameState.money || 0;
            ballCount = gameState.ballCount || 0;
            ballCost = gameState.ballCost || 100;
            speedUpgradeCost = gameState.speedUpgradeCost || 10000;
            speedMultiplier = gameState.speedMultiplier || 1.0;
            totalEarned = gameState.totalEarned || 0;
            lastTotalEarned = gameState.lastTotalEarned || 0;
            estimatedIncome = gameState.estimatedIncome || 0;

            // Restore balls
            balls = [];
            if (gameState.ballsData) {
              gameState.ballsData.forEach((ballData) => {
                let ball = new Ball(ballData.x, ballData.y);
                ball.radius = ballData.radius;
                ball.vx = ballData.vx;
                ball.vy = ballData.vy;
                ball.color = ballData.color;
                balls.push(ball);
              });
            }

            console.log("Game loaded!");
            return true;
          } catch (error) {
            console.error("Error loading game state:", error);
            return false;
          }
        }
        return false;
      }

      // Reset game state
      function resetGameState() {
        money = 100;
        balls = [];
        ballCount = 0;
        ballCost = 100;
        speedUpgradeCost = 10000;
        speedMultiplier = 1.0;
        autoSaveTimer = 0;
        backgroundTimer = 0;
        colorTransitionProgress = 0;
        totalEarned = 100; // Starting money counts as earned
        lastTotalEarned = 0;
        estimatedIncome = 0;
        incomeTimer = 0;
        localStorage.removeItem("ballGameSave");
        updateUI();
        console.log("Game reset!");
      }

      // Ball class
      class Ball {
        constructor(x, y) {
          this.x = x || Math.random() * (canvas.width - 40) + 20;
          this.y = y || Math.random() * (canvas.height - 40) + 20;
          this.radius = Math.random() * 15 + 10;
          this.vx = (Math.random() - 0.5) * 8 * speedMultiplier;
          this.vy = (Math.random() - 0.5) * 8 * speedMultiplier;
          this.color = `hsl(${Math.random() * 360}, 85%, 65%)`;
          this.trail = [];
          this.moneyTimer = 0;
        }

        update() {
          // Update position
          this.x += this.vx * speedMultiplier;
          this.y += this.vy * speedMultiplier;

          // Bounce off walls
          if (this.x <= this.radius || this.x >= canvas.width - this.radius) {
            this.vx = -this.vx;
            this.x = Math.max(
              this.radius,
              Math.min(canvas.width - this.radius, this.x)
            );
          }
          if (this.y <= this.radius || this.y >= canvas.height - this.radius) {
            this.vy = -this.vy;
            this.y = Math.max(
              this.radius,
              Math.min(canvas.height - this.radius, this.y)
            );
          }

          // Check collision with obstacles
          obstacles.forEach((obstacle) => {
            if (this.checkCollisionWithObstacle(obstacle)) {
              this.bounceOffObstacle(obstacle);
            }
          });

          // Add to trail
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > 10) {
            this.trail.shift();
          }

          // Generate money over time
          this.moneyTimer += 1;
          if (this.moneyTimer >= 60) {
            // Every second at 60fps
            money += 1;
            totalEarned += 1;
            this.moneyTimer = 0;
          }
        }

        checkCollisionWithObstacle(obstacle) {
          const dx = this.x - obstacle.x;
          const dy = this.y - obstacle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < this.radius + obstacle.radius;
        }

        bounceOffObstacle(obstacle) {
          const dx = this.x - obstacle.x;
          const dy = this.y - obstacle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < this.radius + obstacle.radius) {
            // Add money reward for hitting obstacle
            money += 10;
            totalEarned += 10;

            // Normalize collision vector
            const nx = dx / distance;
            const ny = dy / distance;

            // Separate balls
            const overlap = this.radius + obstacle.radius - distance;
            this.x += nx * overlap * 0.5;
            this.y += ny * overlap * 0.5;

            // Reflect velocity
            const dotProduct = this.vx * nx + this.vy * ny;
            this.vx -= 2 * dotProduct * nx;
            this.vy -= 2 * dotProduct * ny;
          }
        }

        draw() {
          // Draw trail
          ctx.globalAlpha = 0.3;
          for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = i / this.trail.length;
            ctx.globalAlpha = alpha * 0.3;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(point.x, point.y, this.radius * alpha, 0, Math.PI * 2);
            ctx.fill();
          }

          // Draw ball
          ctx.globalAlpha = 1;
          const gradient = ctx.createRadialGradient(
            this.x - this.radius / 3,
            this.y - this.radius / 3,
            0,
            this.x,
            this.y,
            this.radius
          );
          gradient.addColorStop(0, this.color);
          gradient.addColorStop(1, this.color.replace("65%", "45%"));

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();

          // Add shine effect
          ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
          ctx.beginPath();
          ctx.arc(
            this.x - this.radius / 3,
            this.y - this.radius / 3,
            this.radius / 3,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      }

      // Obstacle class
      class Obstacle {
        constructor(x, y, sides, radius) {
          this.x = x;
          this.y = y;
          this.sides = sides;
          this.radius = radius;
          this.rotation = 0;
          this.rotationSpeed = (Math.random() - 0.5) * 0.02;
          this.color = `hsl(${Math.random() * 60 + 280}, 70%, 55%)`;
        }

        update() {
          this.rotation += this.rotationSpeed;
        }

        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);

          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
          gradient.addColorStop(0, this.color);
          gradient.addColorStop(1, this.color.replace("55%", "35%"));

          ctx.fillStyle = gradient;
          ctx.strokeStyle = this.color.replace("55%", "70%");
          ctx.lineWidth = 3;

          ctx.beginPath();
          for (let i = 0; i < this.sides; i++) {
            const angle = (i / this.sides) * Math.PI * 2;
            const x = Math.cos(angle) * this.radius;
            const y = Math.sin(angle) * this.radius;
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          ctx.restore();
        }
      }

      // Create obstacles
      function createObstacles() {
        obstacles = [];
        const numObstacles = 5;

        for (let i = 0; i < numObstacles; i++) {
          let x, y, radius;
          let validPosition = false;
          let attempts = 0;

          while (!validPosition && attempts < 50) {
            x = Math.random() * (canvas.width - 200) + 100;
            y = Math.random() * (canvas.height - 200) + 100;
            radius = Math.random() * 40 + 30;

            validPosition = true;
            // Check if too close to other obstacles
            for (let obstacle of obstacles) {
              const dx = x - obstacle.x;
              const dy = y - obstacle.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < radius + obstacle.radius + 50) {
                validPosition = false;
                break;
              }
            }
            attempts++;
          }

          if (validPosition) {
            const sides = Math.floor(Math.random() * 5) + 5; // 5-9 sides
            obstacles.push(new Obstacle(x, y, sides, radius));
          }
        }
      }

      // Add ball function
      function addBall() {
        if (money >= ballCost) {
          money -= ballCost;
          balls.push(new Ball());
          ballCount++;
          ballCost = Math.floor(ballCost * 1.5);
          updateUI();
          saveGameState(); // Save after adding ball
        }
      }

      // Upgrade speed function
      function upgradeSpeed() {
        if (money >= speedUpgradeCost) {
          money -= speedUpgradeCost;
          speedMultiplier *= 1.02;
          speedUpgradeCost = Math.floor(speedUpgradeCost * 1.5);

          // Update existing balls' speed
          balls.forEach((ball) => {
            ball.vx *= 1.02;
            ball.vy *= 1.02;
          });

          updateUI();
          saveGameState(); // Save after upgrade
        }
      }

      // Reset game function
      function resetGame() {
        if (
          confirm(
            "Are you sure you want to reset your game? This will delete all progress and cannot be undone!"
          )
        ) {
          resetGameState();
        }
      }

      // Toggle HUD visibility
      function toggleHUD() {
        hudVisible = !hudVisible;
        const ui = document.querySelector(".ui");
        const stats = document.querySelector(".stats");
        const colorControls = document.getElementById("colorControls");

        if (hudVisible) {
          ui.classList.remove("hud-hidden");
          stats.classList.remove("hud-hidden");
          colorControls.classList.remove("hud-hidden");
        } else {
          ui.classList.add("hud-hidden");
          stats.classList.add("hud-hidden");
          colorControls.classList.add("hud-hidden");
        }
      }

      // Update HUD toggle button text
      function updateHUDToggle() {
        const hudToggle = document.getElementById("hudToggle");
        const canAffordAnything =
          money >= ballCost || money >= speedUpgradeCost;
        hudToggle.textContent = canAffordAnything ? "HUD*" : "HUD";
      }

      // Update UI elements
      function updateUI() {
        document.getElementById("moneyDisplay").textContent = `$${formatNumber(
          money
        )}`;
        document.getElementById("ballCount").textContent = ballCount;
        document.getElementById("speedMultiplier").textContent =
          speedMultiplier.toFixed(2) + "x";
        document.getElementById("ballCost").textContent = `$${formatNumber(
          ballCost
        )}`;
        document.getElementById("speedCost").textContent = `$${formatNumber(
          speedUpgradeCost
        )}`;
        document.getElementById("totalEarned").textContent = `$${formatNumber(
          totalEarned
        )}`;
        document.getElementById(
          "estimatedIncome"
        ).textContent = `~ $${formatNumber(estimatedIncome)} / min`;
        document.getElementById("buyNextETA").textContent =
          calculateBuyNextETA();

        // Update button text
        document.getElementById(
          "addBallBtn"
        ).textContent = `+ Ball ($${formatNumber(ballCost)})`;
        document.getElementById(
          "upgradeSpeedBtn"
        ).textContent = `Upgrade Speed ($${formatNumber(speedUpgradeCost)})`;

        // Update button states
        document.getElementById("addBallBtn").disabled = money < ballCost;
        document.getElementById("upgradeSpeedBtn").disabled =
          money < speedUpgradeCost;

        // Update HUD toggle button
        updateHUDToggle();
      }

      // Game loop
      function animate() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update and draw obstacles
        obstacles.forEach((obstacle) => {
          obstacle.update();
          obstacle.draw();
        });

        // Update and draw balls
        balls.forEach((ball) => {
          ball.update();
          ball.draw();
        });

        // Auto-save every 5 minutes (300 seconds * 60 fps = 18000 frames)
        autoSaveTimer++;
        if (autoSaveTimer >= 18000) {
          saveGameState();
          autoSaveTimer = 0;
        }

        // Update background color cycling (30 minutes total = 1800 seconds = 108000 frames)
        // Each color lasts ~2.5 minutes = 150 seconds = 9000 frames
        backgroundTimer++;
        const colorDuration = 9000; // frames per color

        if (backgroundTimer >= colorDuration) {
          // Move to next color
          backgroundTimer = 0;
          currentColorIndex = nextColorIndex;
          nextColorIndex = (nextColorIndex + 1) % colorThemes.length;
          colorTransitionProgress = 0;

          // If we've completed a full cycle, shuffle the themes again
          if (currentColorIndex === 0) {
            shuffleColorThemes();
          }
        } else {
          // Update transition progress (smooth transition over 30 seconds = 1800 frames)
          const transitionDuration = 1800;
          if (backgroundTimer <= transitionDuration) {
            colorTransitionProgress = backgroundTimer / transitionDuration;
          } else {
            colorTransitionProgress = 1;
          }
        }

        // Apply background gradient update
        updateBackgroundGradient();

        // Update income tracking every minute (60 seconds * 60 fps = 3600 frames)
        incomeTimer++;
        if (incomeTimer >= 3600) {
          estimatedIncome = totalEarned - lastTotalEarned;
          lastTotalEarned = totalEarned;
          incomeTimer = 0;
        }

        // Update UI
        updateUI();

        requestAnimationFrame(animate);
      }

      // Event listeners
      document.getElementById("addBallBtn").addEventListener("click", addBall);
      document
        .getElementById("upgradeSpeedBtn")
        .addEventListener("click", upgradeSpeed);
      document.getElementById("resetBtn").addEventListener("click", resetGame);
      document.getElementById("hudToggle").addEventListener("click", toggleHUD);

      // Handle window resize
      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        createObstacles();
      });

      // Initialize game
      createObstacles();

      // Try to load saved game state
      if (!loadGameState()) {
        // If no save data, start with default values
        money = 100; // Start with some money
        totalEarned = 100; // Starting money counts as earned
      }

      // Initialize background gradient and color buttons
      createColorButtons();
      updateBackgroundGradient();

      updateUI();
      animate();

      // Add some initial balls for demonstration (only if no balls loaded)
      setTimeout(() => {
        if (balls.length === 0) {
          addBall();
        }
      }, 1000);
    </script>
  </body>
</html>
